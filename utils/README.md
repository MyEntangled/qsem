This code implements the method from the paper "Quantum algorithm for solving nonlinear differential equations based on physics-informed effective Hamiltonians".
Note: we adapt the method to the generalized encoding vector $\vec\tau_d(x) = \frac{1}{\sqrt{d+1}}\left(T_0(x), \sqrt{2}T_1(x), \sqrt{2}T_2(x), \dots, \sqrt{2} T_d(x) \right)$, where $T_n(x)$ is the Chebyshev polynomial of the first kind with degree $n \leq d$  for any maximum degree $d \in \mathbb{N}$, whereas the paper assumes $d = 2^n-1$.

### Ingredients
The method constructs an effective Hamiltonian from the differential equation and boundary conditions such that its ground state $\vec\psi$ represents the solution to the problem via the scalar product $\vec\tau_d \cdot \vec\psi$. Since $\|\vec \psi\| = 1$, the final solution has to be rescaled, $f_Q(x) = \sqrt{\eta} \vec\tau_d \cdot \vec\psi$. The encoding of the differential equation into the Hamiltonian involves a few quantum operators.

1. Differentiation operator $\mathbb{G} \in \mathbb{R}^{(d+1) \times (d+1)}$ is a constant matrix such that $\frac{\mathrm{d}}{\mathrm{d}x}\vec\tau_d(x) = \mathbb{G} \, \vec\tau_d(x)$, or 
$$\begin{bmatrix}T'_0(x) \\ \sqrt{2} T'_1(x) \\ \vdots \\ \sqrt{2} T'_d(x) \end{bmatrix} = \mathbb{G} \begin{bmatrix}T_0(x) \\ \sqrt{2} T_1(x) \\ \vdots \\ \sqrt{2} T_d(x) \end{bmatrix} \quad \forall x.$$
For example, for $d=3$, the left-hand side is $\left[0, \sqrt{2}T_0, 4\sqrt{2}T_1, 6\sqrt{2}T_2 + 3\sqrt{2}T_0 \right]^\top$, hence $\mathbb{G} = \begin{bmatrix} 0 & 0 & 0 & 0 \\ \sqrt{2} & 0 & 0 & 0 \\ 0 & 4 & 0 & 0 \\ 3\sqrt{2} & 0 & 6 & 0 \end{bmatrix}$. The paper uses the transpose $\mathbb{G}^\top$ because it multiplies with the bra $\langle \; |$, but it's just the row vector $\tau^\top$. Eq. (4) in the paper is basically $f'_Q(x) = \sqrt{\eta} \frac{\mathrm{d}}{\mathrm{d}x} \tau(x)^\top = \sqrt{\eta} \, \tau(x)^\top \mathbb{G}^\top$. We compute the differentiation matrix using (1) $T'_n(x) = nU_{n-1}(x)$, where $U_n$ is the Chebyshev polynomial of the second kind and (2) the identity
$$ U_n(x) = \left\{ \begin{matrix} 2 \sum_{\text{odd } k \geq0}^n T_k(x), \quad n \text{ odd} \\ -1 + 2 \sum_{\text{even } k \geq0}^n T_k(x) , \quad n \text{ even}\end{matrix} \right.$$

2. Multiplication operator $\mathbb{M}_{x^p}$ such that $ x^p \vec\tau_d(x) = \mathbb{M}_{x^p} \, \vec\tau_{d'}(x) $. Since the highest degree on the left-hand side is $d + p$, we can encode it using the polynomial basis up to degree $d' \geq d+p$. The matrix $\mathbb{M}_{x^p} \in \mathbb{R}^{(d'+1) \times (d+1)}$ can be computed using $x T_0 = T_1$ and $x T_n = \frac{1}{2} T_{n+1} + \frac{1}{2} T_{n-1}$ for $n \geq 1$. (Be careful with different normalizations  $\sqrt{d'+1}$ and $\sqrt{d+1}$.)

3. Self-multiplication operator $\mathbb{N}_1$ such that $\vec\tau_d \otimes \vec\tau_d = \mathbb{N}_1 \vec \tau_{d'}$. The vector on the left-hand side has size $(d+1)^2$ with every cross term $T_0 T_0$, $T_0 T_1$, all the way up to $T_d T_d$ (each with its coefficient). So the maximum degree is $2d$, which means we can choose any $d' \geq 2d$. We compute $\mathbb{N}_1 \in \mathbb{R}^{(d'+1) \times (d+1)^2}$ using $T_n T_m = \frac{1}{2}  (T_{n+m} + T_{|n-m|})$ for $0 \leq n,m \leq d$. The operator $\mathbb{N}_x$ such that $x (\vec\tau_d \otimes \vec\tau_d) = \mathbb{N}_x \vec \tau_{d'}$ is calculated via $\mathbb{N}_x = \mathbb{M}_x \mathbb{N}_1$ using the matrices $\mathbb{M}_{x^p} \in \mathbb{R}^{(d'+1) \times (d''+1)}$ and $\mathbb{N}_1 \in \mathbb{R}^{(d''+1) \times (d+1)^2}$ with an intermediate degree $d''$ chosen appropriately.